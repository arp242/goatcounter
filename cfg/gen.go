// Copyright Â© 2019 Martin Tournoij <martin@arp242.net>
// This file is part of GoatCounter and published under the terms of the EUPL
// v1.2, which can be found in the LICENSE file or at http://eupl12.zgo.at

// +build go_run_only

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"strings"
	"text/template"
)

var flags = []flag{
	{"bool", "Prod", "prod", false, "Production mode: hide errors, don't reload."},
	{"string", "Version", "version", "", "Version tag; normally set during compile"},
	{"string", "Domain", "domain", "goatcounter.localhost", "Base domain"},
	{"string", "DomainStatic", "domainstatic", "static.goatcounter.localhost", "Comma-separated list of domain to serve static files from."},
	{"string", "Listen", "listen", "localhost:8081", "Address to listen on."},
	{"string", "DBFile", "dbconnect", "db/goatcounter.sqlite3", "Database connection string."},
	{"bool", "PgSQL", "pgsql", false, "Use PostgreSQL instead of SQLite"},
	{"string", "SMTP", "smtp", "", "SMTP connection string; outputs to stdout when empty."},
	{"string", "EmailErrors", "emailerrors", "", "Email errors to this address"},
	{"string", "Stripe", "stripe", "", "Stripe keys: need secret, publishable, and webhook (sk_*, pk_*, whsec_*) keys as colon-separated"},
	{"string", "CPUProfile", "cpuprofile", "", "Write CPU profile to this file."},
	{"string", "MemProfile", "memprofile", "", "Write memory profile to this file."},
	{"string", "CertDir", "certdir", "", "Directory to store ACME-generated certificates for custom domains"},
	{"string", "Plan", "plan", "business", "Plan for new installations"},
	{"string", "Debug", "debug", "", "Modules to debug, comma-separated or 'all' for all modules."},
	{"string", "TLS", "tls", "", "Path to TLS certificate and keyfile, as 'certfile:keyfile', which should be a wildcard cert for *.domain. Port 80 will be redirected automatically."},
}

type flag struct {
	Type    string      // Go type name (e.g. bool, string, etc.)
	Name    string      // Variable name in the cfg package (e.g. Listen).
	Flag    string      // Flag name (e.g. "listen")
	Default interface{} // Default value.
	Help    string      // Help text.
}

func main() {
	longest := 0
	for _, f := range flags {
		if len(f.Name) > longest {
			longest = len(f.Name)
		}
	}

	var buf bytes.Buffer
	err := tpl.Execute(&buf, struct {
		Flags   []flag
		Longest int
	}{flags, longest})
	if err != nil {
		_, _ = fmt.Fprintf(os.Stderr, "template: %s\n", err)
		os.Exit(1)
	}

	src, err := format.Source(buf.Bytes())
	if err != nil {
		_, _ = fmt.Fprintf(os.Stderr, "gofmt: %s\n", err)
		os.Exit(1)
	}

	fmt.Print(string(src))
}

var tpl = template.Must(template.New("").
	Option("missingkey=error").
	Funcs(template.FuncMap{
		"ucfirst": func(s string) string { return strings.Title(s) },
		"pad":     func(s string, l int) string { return s + strings.Repeat(" ", l-len(s)) },
	}).
	Parse(`//go:generate sh -c "go run gen.go > cfg.go"

// Code generated by gen.go; DO NOT EDIT.

// Package cfg handles the application configuration.
package cfg

import (
    "flag"
    "fmt"
)

// Configuration variables.
var ({{range $f := .Flags}}
    {{$f.Name}} {{$f.Type}} // {{.Help}}{{end}}
)

// Set configuration variables from os.Args.
func Set() {{"{"}}{{range $f := .Flags}}
    flag.{{$f.Type|ucfirst}}Var(&{{$f.Name}}, "{{$f.Flag}}", {{printf "%#v" $f.Default}}, "{{$f.Help}}"){{end}}
    flag.Parse()
}

// Print out all configuration values.
func Print() {{"{"}}{{range $f := .Flags}}
    fmt.Printf("{{pad $f.Name $.Longest}}   %#v\n", {{$f.Name}}){{end}}
}
`))
